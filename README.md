# Оптимизация функции (UDF) возврата списка заказов
Задание к курсу Оптимизация БД

## Описание
В репозитории находится скрипт для создания объектов БД (MS SQL Server) - `Create objects.sql`.
Описание таблиц:
* `Works` - заказы на проведение исследований
* `WorkItem` - элементы заказа (заказанное исследование)
* `Analiz` - спецификации исследования
* `Employee` - сотрудники

Остальные таблицы для выполнения задания значения не имеют.

Для получения списка заказов с заранее настроенным количеством со стороны клиентского приложения направляется запрос:

`select top 3000 * from dbo.F_WORKS_LIST()`

## Начальные действия
>  1. Ознакомиться со скриптом создания базы данных
2. Ознакомиться с программными компонентами (функции)
3. Разработать и применить генератор тестовых данных 

> Ожидаемый результат - доступная для оптимизации БД с тестовыми данными

Скрипты для заполнения таблиц см. в `synth_data_generation.sql`

## Проблема
Пользователи приложения пользуются на низкую производительность при загрузке списка, при этом отсутствуют возможности отладить приложение и внести в него правки.

## Задача 1-го уровня

> Проанализировать скрипт функции получения списка заказов и связанные с ней объекты, перечислить выявленные недочёты и потенциальные проблемы производительности.

Недочеты и потенциальные причины проблем с производительностью:

* **Вызов 3-х скалярных UDF для каждой строки**: вызов UDF является подзапросом, и при 50000 строк их приходится делать 3\*50000 = 150000. Согласно [свежей документации MS SQL Server](https://learn.microsoft.com/en-us/sql/relational-databases/user-defined-functions/scalar-udf-inlining?view=sql-server-ver17), UDF сильно замедляют обработку запроса, т.к. не могут распараллеливаться внутри него и каждый оператор в UDF выполняется последовательно, изолированно от остальных. UDF также не участвуют должным образом в подсчете стоимости при выборе плана выполнения. 

    Одна только dbo.F_EMPLOYEE_FULLNAME вызывается каждый раз, когда встречается заказ, обработанный тем же сотрудником (если им обработано 5000 заказов, одни и те же действия повторятся 5000 раз), хотя можно было бы сконструировать ФИО один раз и просто приджойнить (с учетом того, что сотрудников немного, по сравнению с заказами). Операции JOIN уже хорошо оптимизируются.

* **ORDER BY id_work DESC в функции dbo.F_WORKS_LIST не влияет на порядок записей в результате** (это видно при попытке запуска запроса `SELECT TOP 3000 * FROM dbo.F_WORKS_LIST(`)), так как для табличной переменной не существует такого понятия. Если не менять UDF на подзапрос, то для получения последних N заказов сортировку нужно выносить во внешний запрос.

* Если групповых анализов столько же, сколько и негрупповых, или больше, то в dbo.F_WORKITEMS_COUNT_BY_ID_WORK эффективнее будет проверять
    ```sql
    id_analiz IN (SELECT id_analiz FROM analiz WHERE is_group = 0)
    ```
    вместо
    ```sql
    id_analiz NOT IN (SELECT id_analiz FROM analiz WHERE is_group = 1)
    ```

* В определении функции dbo.F_WORKS_LIST есть строка
    ```sql
    WHERE Works.Is_Del <> 1
    ```
    которую можно заменить на
    ```sql
    WHERE Works.Is_Del = 0
    ```
    так как в определении таблицы dbo.Works указано, что Is_Del принимает только значения 0/1
    ```sql
    [Is_Del] [bit] NOT NULL
    ```
    и автоматически заполняется нулем (не бывает NULL)
    ```sql
    ALTER TABLE [dbo].[Works] ADD  DEFAULT ((0)) FOR [Is_Del]
    ```
    Как минимум, строка со сравнением на равенство лучше читается.


## Задача 2-го уровня

> Предложить правки запросов без модификации структуры БД такие, что время выполнения запроса получения `3 000` заказов из `50 000` со средним количеством элементов в заказе равным `3` не будет превышать `1-2` сек.

Возможные модификации:

* **Заменить UDF dbo.F_WORKITEMS_COUNT_BY_ID_WORK на табличное выражение**, где сразу будет посчитано число завершенных и незавершенных частей заказов, которое будет просто джойниться по id заказа (Id_Work). 

    Это уже дает заметно лучшую производительность (0.33 секунды против 10+ секунд для оригинальной функции) для запроса выборки из 50000 заказов
    ```sql
    SELECT TOP 3000 * FROM dbo.F_WORKS_LIST_NEW() ORDER BY Id_Work DESC
    ```

    Для удобства переиспользования вместо табличного выражения можно использовать представление (view) или параметризованную встроенную таблично-значную функцию (inline TVF).

    В файле `udf_optimization.sql` представлены два варианта: с табличным выражением и с iTVF.

* **Заменить UDF dbo.F_EMPLOYEE_FULLNAME на iTVF**

    Так как сотрудников должно быть немного относительно заказов (если храним заказы за несколько лет и есть постоянный поток новых), то JOIN на такую небольшую таблицу будет эффективен.

* **Создать фильтрованный индекс по Is_Del в таблице dbo.Works**

    Так как в dbo.F_WORKS_LIST мы смотрим только на неотмененные (неудаленные) заказы, можно создать некластерный фильтрованный индекс для таких заказов по столбцам, использующимся в JOIN, и включить в него только необходимые для данной функции столбцы.

    При малом количестве удаленных заказов заметного выигрыша в производительности относительно шага 2 мы не получаем, но, судя по плану запроса, планировщик, по крайней мере, использует этот индекс. 

См. в файле `udf_optimization.sql` 

Использованные промпты:
* About the WorkItems subquery: How to make it reusable? The procedure was useful because I could define it once and then use just its name and parameters.
* How to optimize dbo.F_EMPLOYEE_FULLNAME?
* Can you tell me how I can use indexes to make it even better?

## Задача 3-го уровня

> Если для оптимизации требуется создание новых таблиц, столбцов, триггеров или хранимых процедур (функций), то необходимо описать возможные недостатки и отрицательные последствия от таких изменений.

Недостатки iTVF:
1. iTVF может препятствовать переиспользованию имеющегося плана запроса (что доступно в MS SQL Server), заставляя планировщик генерировать его заново при каждом запуске. Это увеличивает время компиляции.
2. Если iTVF возвращает большой набор данных (сотни тысяч, миллионы строк), SQL Server может быть вынужден сбросить промежуточные данные на диск (в tempdb), что значительно замедлит запрос.
3. iTVF не поддерживает создание индексов по возвращаемому набору, поэтому JOIN на большую таблицу может быть очень неэффективен.

Недостатки индекса:
1. Добавленные столбцы увеличивают размер индекса, т.е. он занимает больше места (и в целом, занимает место на диске), и его сложнее поддерживать (т.к. при вставках, изменениях и удалениях его надо обновлять).
2. Будет использоваться только в запросах с условием `Is_Del = 0` (не будет для `Is_Del = 1`, для таких нужен отдельный индекс).
3. Со временем из-за вставок/изменений/удалений становится фрагментированным, поэтому его нужно перестраивать.